- Calling Stack 함수 호출 관계

- 재귀 알고리즘 활용 익히기

  재귀 : 함수가 자기 자신을 호출하는 것. 

  스택 오버 플로우 : 스택에 함수가 쌓이는 것.



Node.js는 Chrome V8 Javasript 엔진으로 빌드된 Javascript 런타임(실행환경)이다.

자바스크립트를 실행할 수 있고, 크롬 V8로 만들어졌다.

OS? Oh yes! (책)

서버뿐만 아니라 다른 일도 할 수 있다. 





코드를 컴파일하면 컴파일러는 기본 데이터타입을 검사해 필요한 메모리의 크기를 계산한다. 그러면 필요로 하는 만큼의 양이 스택 스페이스(stack space)라는 곳에서 프로그램에 할당된다. 



#### 메모리 공간

1. **데이터 영역**
   1. 전역 변수가 데이터 영역에 들어감
2. **코드 영역**
   1. 프로그램 코드가 번역된 기계어로 들어감
   2. 프로세스의 코드 영역은 건드릴 수 없다. 이걸 바꾸는 게 해킹.
3. **힙**
   1. 참조변수가 가리키는 것들은 힙에 들어감. 객체, 배열 등이 힙에 들어감. (JAVA에서 new하면 힙에 들어감.). 동적 할당 공간.
   2. 표준입력도 힙에 들어감. 
4. **스택**
   1. 지역변수는 스택에 들어감.
   2. 스택은 쌓이는 공간이다.
   3. 함수를 실행할 때마다 스택이 쌓인다. 함수가 종료되면 스택은 날라감.
   4. 함수를 한 번 호출하면 스택이 쌓이고 끝나면 스택이 사라지는데 재귀호출하면 함수가 끝나지 않기 때문에 스택이 계속 쌓이는 것. Stack OverFlow.
   5. 현재 작업의 위치를 기록하는 자료구조이다.(?) 우리가 프로그램의 어디에 있는지 기록하는 자료구조.
   6. 콜스택의 각각은 스택프레임(Stack Frame)이라고 한다. 
   7. 스택 날림 : 콜 스택의 최대 크기에 다다랐을 때 나타남.



#### 비동기

const id = setTimeOut (() => {

console.log("hello")}, 5000);

콜 스택. 함수를 콜 해야 쌓이니까 콜 스택. 이벤트는 비동기로 호출이 된다. 이벤트 큐에 함수(이벤트)가 쌓인다. 콜 스택이 비어 있을 경우에만 이벤트 큐에 있는 이벤트를 호출한다. 

콜 스택이 이벤트 큐보다 우선한다. 콜 스택에 실행할 함수가 없을 때 이벤트 큐에 있는 이벤트를 호출한다.





#### 재귀

자기 자신을 다시 호출하는 것.



---

global : 전역객체



const foo = function(x) {

​	let y = x * 2;

​	console.log(x, y)	

}



z = 10;

zz = foo(z)

console.log(zz)



1. 스택 x라는 변수 생성
2. x의 값을 복사함
3. x = 10



return : 함수를 종료, 값을 반환한다.





[y = 20]

[x = 10]

ㅡㅡㅡㅡ



zz <-------= 20

x에 20을 전달하고 위의 x와 y는 사라짐



----

#### 재귀

*재귀를 사용하면 개발자가 좋고 재귀를 사용 안 하면 프로그램이 좋다*

1. 위에서부터 아래로 코드를 작성하는 게 좋다.
2. 종료 조건을 먼저 작성하는 게 좋다.





**피보나치 수열  구현하기**

빠르게 돌리려면 어떻게 해야하나...



O(n)

n은 코드를 n번 실행했다는 것

이중 루프를 하면 n 제곱

피보나치는 2의 n승